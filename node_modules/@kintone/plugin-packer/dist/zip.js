"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateContentsZip = exports.rezip = void 0;
const path_1 = __importDefault(require("path"));
const yazl = __importStar(require("yazl"));
const yauzl = __importStar(require("yauzl"));
const util_1 = require("util");
const plugin_manifest_validator_1 = __importDefault(require("@kintone/plugin-manifest-validator"));
const streamBuffers = __importStar(require("stream-buffers"));
const gen_error_msg_1 = require("./gen-error-msg");
const sourcelist_1 = require("./sourcelist");
/**
 * Extract, validate and rezip contents.zip
 */
const rezip = (contentsZip) => {
    return preprocessToRezip(contentsZip).then(({ zipFile, entries, manifestJson, manifestPath }) => {
        validateManifest(entries, manifestJson, manifestPath);
        return rezipContents(zipFile, entries, manifestJson, manifestPath);
    });
};
exports.rezip = rezip;
/**
 * Validate a buffer of contents.zip
 */
const validateContentsZip = (contentsZip) => {
    return preprocessToRezip(contentsZip).then(({ entries, manifestJson, manifestPath }) => validateManifest(entries, manifestJson, manifestPath));
};
exports.validateContentsZip = validateContentsZip;
/**
 * Create an intermediate representation for contents.zip
 */
const preprocessToRezip = (contentsZip) => {
    return zipEntriesFromBuffer(contentsZip).then((result) => {
        const manifestList = Array.from(result.entries.keys()).filter((file) => path_1.default.basename(file) === "manifest.json");
        if (manifestList.length === 0) {
            throw new Error("The zip file has no manifest.json");
        }
        else if (manifestList.length > 1) {
            throw new Error("The zip file has many manifest.json files");
        }
        result.manifestPath = manifestList[0];
        const manifestEntry = result.entries.get(result.manifestPath);
        return getManifestJsonFromEntry(result.zipFile, manifestEntry).then((json) => Object.assign(result, { manifestJson: json }));
    });
};
const getManifestJsonFromEntry = (zipFile, zipEntry) => {
    return zipEntryToString(zipFile, zipEntry).then((str) => JSON.parse(str));
};
const zipEntriesFromBuffer = (contentsZip) => {
    return (0, util_1.promisify)(yauzl.fromBuffer)(contentsZip).then((zipFile) => new Promise((res, rej) => {
        const entries = new Map();
        const result = {
            zipFile,
            entries,
        };
        zipFile === null || zipFile === void 0 ? void 0 : zipFile.on("entry", (entry) => {
            entries.set(entry.fileName, entry);
        });
        zipFile === null || zipFile === void 0 ? void 0 : zipFile.on("end", () => {
            res(result);
        });
        zipFile === null || zipFile === void 0 ? void 0 : zipFile.on("error", rej);
    }));
};
const zipEntryToString = (zipFile, zipEntry) => {
    return new Promise((res, rej) => {
        zipFile.openReadStream(zipEntry, (e, stream) => {
            if (e) {
                rej(e);
            }
            else {
                const output = new streamBuffers.WritableStreamBuffer();
                output.on("finish", () => {
                    res(output.getContents().toString("utf8"));
                });
                stream === null || stream === void 0 ? void 0 : stream.pipe(output);
            }
        });
    });
};
const validateManifest = (entries, manifestJson, manifestPath) => {
    var _a;
    // entry.fileName is a relative path separated by posix style(/) so this makes separators always posix style.
    const getEntryKey = (filePath) => path_1.default
        .join(path_1.default.dirname(manifestPath), filePath)
        .replace(new RegExp(`\\${path_1.default.sep}`, "g"), "/");
    const result = (0, plugin_manifest_validator_1.default)(manifestJson, {
        relativePath: (filePath) => entries.has(getEntryKey(filePath)),
        maxFileSize: (maxBytes, filePath) => {
            const entry = entries.get(getEntryKey(filePath));
            if (entry) {
                return entry.uncompressedSize <= maxBytes;
            }
            return false;
        },
    });
    if (!result.valid) {
        const errors = (0, gen_error_msg_1.generateErrorMessages)((_a = result.errors) !== null && _a !== void 0 ? _a : []);
        const e = new Error(errors.join(", "));
        e.validationErrors = errors;
        throw e;
    }
};
const rezipContents = (zipFile, entries, manifestJson, manifestPath) => {
    const manifestPrefix = path_1.default.dirname(manifestPath);
    return new Promise((res, rej) => {
        const newZipFile = new yazl.ZipFile();
        newZipFile.on("error", rej);
        const output = new streamBuffers.WritableStreamBuffer();
        output.on("finish", () => {
            res(output.getContents());
        });
        newZipFile.outputStream.pipe(output);
        const openReadStream = (0, util_1.promisify)(zipFile.openReadStream.bind(zipFile));
        Promise.all((0, sourcelist_1.sourceList)(manifestJson).map((src) => {
            const entry = entries.get(path_1.default.join(manifestPrefix, src));
            return openReadStream(entry).then((stream) => {
                newZipFile.addReadStream(stream, src, {
                    size: entry.uncompressedSize,
                });
            });
        })).then(() => {
            newZipFile.end();
        });
    });
};
//# sourceMappingURL=zip.js.map